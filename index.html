<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Controle de Lotes ‚Äî Entrega & Retirada</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"/>
<style>
  :root{
    --primary:#2563eb; --accent:#0ea5e9; --bg:#f6fbff; --card:#fff; --text:#0f172a;
    --muted:#6b7280; --success:#10b981; --warning:#f59e0b;
    --status-carregado: #10b981; /* Verde */
    --status-embarque: #3b82f6; /* Azul */
    --status-transito: #ef4444; /* Vermelho */
    --status-contratar: #f97316; /* Laranja */
    --produto-soja: #10b981; /* Verde para Soja */
    --produto-milho: #fbbf24; /* Amarelo para Milho */
    --produto-sorgo: #6b7280; /* Cinza para Sorgo */
  }
  *{box-sizing:border-box}
  body{font-family:Inter, "Segoe UI", Roboto, Arial, sans-serif;margin:0;background:var(--bg);color:var(--text);padding:12px}
  header{background:linear-gradient(90deg,var(--primary),var(--accent));color:white;padding:12px;border-radius:8px;margin-bottom:16px;text-align:center;font-weight:700;display:flex;align-items:center;justify-content:center;gap:8px}
  .wrap{max-width:1400px;margin:0 auto;width:100%}
  .actions{display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;flex-wrap:wrap;gap:12px}
  .btn{background:var(--primary);color:#fff;border:0;padding:8px 12px;border-radius:6px;cursor:pointer;font-weight:700;font-size:14px}
  .btn:hover{opacity:.95}
  .last-update{color:var(--muted);font-size:12px;display:flex;align-items:center;gap:6px}
  .last-update i{font-size:14px;animation:spin 2s linear infinite}
  @keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
  .updating .last-update i{animation:spin 1s linear infinite}
  /* Cards de Status no topo - vers√£o compacta */
  .status-cards{display:flex;flex-wrap:wrap;gap:12px;margin-bottom:20px}
  .status-card{background:var(--card);border-radius:8px;padding:12px;box-shadow:0 3px 8px rgba(0,0,0,0.06);flex:1;min-width:160px;text-align:center;transition:all 0.3s ease}
  .status-card:hover{transform:translateY(-2px);box-shadow:0 5px 12px rgba(0,0,0,0.08)}
  .status-card h3{margin:0 0 6px 0;font-size:14px;color:var(--text);font-weight:600}
  .status-card .count{font-size:24px;font-weight:700;margin:6px 0}
  .status-card-carregado{border-top:3px solid var(--status-carregado);}
  .status-card-embarque{border-top:3px solid var(--status-embarque);}
  .status-card-transito{border-top:3px solid var(--status-transito);}
  .status-card-contratar{border-top:3px solid var(--status-contratar);}
  /* Cards de Produtos - vers√£o compacta */
  .produto-cards{display:flex;flex-wrap:wrap;gap:12px;margin-bottom:20px}
  .produto-card{background:var(--card);border-radius:8px;padding:10px;box-shadow:0 3px 8px rgba(0,0,0,0.06);flex:1;min-width:150px;text-align:center;transition:all 0.3s ease;border-top:3px solid transparent}
  .produto-card:hover{transform:translateY(-2px);box-shadow:0 5px 12px rgba(0,0,0,0.08)}
  .produto-card h3{margin:0 0 4px 0;font-size:13px;color:var(--text);font-weight:600}
  .produto-card .count{font-size:20px;font-weight:700;margin:4px 0}
  .produto-soja{border-top-color: var(--produto-soja);}
  .produto-milho{border-top-color: var(--produto-milho);}
  .produto-sorgo{border-top-color: var(--produto-sorgo);}
  /* Se√ß√£o de Clientes e Destinos */
  .clientes-section{margin-bottom:24px}
  .clientes-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
  .clientes-title{color:var(--primary);font-weight:700;font-size:18px}
  .clientes-summary{color:var(--muted);font-size:14px}
  .clientes-container{display:grid;grid-template-columns:repeat(auto-fill,minmax(300px,1fr));gap:16px;margin-bottom:24px}
  .cliente-card{background:var(--card);border-radius:8px;padding:14px;box-shadow:0 3px 8px rgba(0,0,0,0.06);transition:all 0.3s ease}
  .cliente-card:hover{transform:translateY(-2px);box-shadow:0 5px 12px rgba(0,0,0,0.08)}
  .cliente-name{font-weight:700;font-size:15px;color:var(--text);margin:0 0 6px 0}
  .cliente-destino{font-weight:600;color:var(--accent);margin:0 0 10px 0;font-size:13px}
  .cliente-info{display:flex;justify-content:space-between;margin-bottom:6px;align-items:center}
  .info-label{font-weight:600;color:var(--muted);font-size:12px}
  .info-value{font-weight:700;font-size:13px}
  .cliente-produto{padding:3px 7px;border-radius:5px;font-size:11px;font-weight:600;display:inline-block;margin-top:4px}
  .status-carregado-tag{background-color: var(--status-carregado);color: white;padding: 2px 7px;border-radius: 10px;font-size: 11px;font-weight: 600;}
  .status-pendente-tag{background-color: var(--status-embarque);color: white;padding: 2px 7px;border-radius: 10px;font-size: 11px;font-weight: 600;}
  .caminhoes-info{display:flex;gap:8px;margin-top:6px;padding-top:6px;border-top:1px solid #eee}
  .caminhoes-separados{display:flex;gap:6px;align-items:center}
  /* T√≠tulos expans√≠veis */
  .section-header{background:linear-gradient(90deg,var(--primary),var(--accent));color:white;padding:12px;border-radius:8px;margin-bottom:12px;cursor:pointer;display:flex;justify-content:space-between;align-items:center;font-weight:700;transition:all 0.3s ease;font-size:15px}
  .section-header:hover{opacity:0.95}
  .section-header .toggle-icon{transition:transform 0.3s ease}
  .section-header.collapsed .toggle-icon{transform:rotate(-90deg)}
  .section-content{display:block;transition:all 0.3s ease;overflow:hidden}
  .section-content.collapsed{display:none}
  h2{color:var(--primary);margin:6px 0 12px 0;font-size:18px}
  .card{background:var(--card);border-radius:8px;padding:12px;margin-bottom:16px;box-shadow:0 4px 12px rgba(16,24,40,0.06)}
  .table-wrap{overflow-x:auto}
  table{width:100%;border-collapse:collapse;margin:0;font-size:12px;min-width:750px}
  th,td{border:1px solid #e6eefc;padding:8px;text-align:left;vertical-align:top}
  th{background:linear-gradient(90deg,var(--primary),var(--accent));color:#fff;font-weight:700;white-space:nowrap}
  tr:nth-child(even){background:#fbfdff}
  .status{display:inline-block;padding:5px 9px;border-radius:14px;color:#fff;font-weight:700;font-size:11px}
  .status-aberto{background:var(--warning)}
  .status-fechado{background:var(--success)}
  /* Estilos para os novos status da programa√ß√£o */
  .status-programacao{display:inline-block;padding:5px 10px;border-radius:14px;color:#fff;font-weight:700;font-size:11px;min-width:90px;text-align:center}
  .status-carregado{background-color: var(--status-carregado);}
  .status-embarque{background-color: var(--status-embarque);}
  .status-transito{background-color: var(--status-transito);}
  .status-contratar{background-color: var(--status-contratar);}
  .empty{color:var(--muted);font-style:italic;padding:10px}
  @media (max-width:900px){
    table{min-width:650px}
    th, td{padding:6px;font-size:11px}
    .status-cards, .produto-cards{flex-direction:column}
    .clientes-container{grid-template-columns:1fr}
    .cliente-card{min-width:260px}
  }
  @media (max-width:600px){
    body{padding:8px}
    .section-header{padding:10px;font-size:14px}
    .cliente-card{min-width:100%;padding:12px}
    .status-card{min-width:140px;padding:10px}
    .produto-card{min-width:130px;padding:8px}
  }
</style>
</head>
<body>
  <!-- Cabe√ßalho com imagem PNG do GitHub -->
  <header>
    <img src="https://raw.githubusercontent.com/mvkpasta-prog/planilhas-lotes/main/mvklogo.png" alt="Logo MVK" style="height: 22px; vertical-align: middle; margin-right: 8px;">
    Controle de Lotes ‚Äî Entrega & Retirada
  </header>
  <div class="wrap">
    <div class="actions">
      <button id="btnRefresh" class="btn"><i class="fas fa-sync-alt"></i> Atualizar</button>
      <div class="last-update" id="lastUpdate">
        <i class="fas fa-circle-notch"></i>
        <span>Atualizando...</span>
      </div>
    </div>
    <!-- Cards de Status -->
    <div class="status-cards">
      <div class="status-card status-card-carregado">
        <h3>CARREGADO</h3>
        <div class="count" id="count-carregado">0</div>
        <div>Ve√≠culos</div>
      </div>
      <div class="status-card status-card-embarque">
        <h3>NO EMBARQUE</h3>
        <div class="count" id="count-embarque">0</div>
        <div>Ve√≠culos</div>
      </div>
      <div class="status-card status-card-transito">
        <h3>EM TR√ÇNSITO</h3>
        <div class="count" id="count-transito">0</div>
        <div>Ve√≠culos</div>
      </div>
      <div class="status-card status-card-contratar">
        <h3>CONTRATAR</h3>
        <div class="count" id="count-contratar">0</div>
        <div>Ve√≠culos</div>
      </div>
    </div>
    <!-- Cards de Produtos -->
    <div class="produto-cards">
      <div class="produto-card produto-soja">
        <h3>SOJA</h3>
        <div class="count" id="count-soja">0</div>
        <div>KG</div>
      </div>
      <div class="produto-card produto-milho">
        <h3>MILHO</h3>
        <div class="count" id="count-milho">0</div>
        <div>KG</div>
      </div>
      <div class="produto-card produto-sorgo">
        <h3>SORGO</h3>
        <div class="count" id="count-sorgo">0</div>
        <div>KG</div>
      </div>
    </div>
    <!-- Se√ß√£o de Clientes e Destinos -->
    <div class="clientes-section">
      <div class="clientes-header">
        <h2 class="clientes-title">üöö Clientes e Destinos</h2>
        <div class="clientes-summary" id="clientesSummary">Carregando...</div>
      </div>
      <div class="clientes-container" id="clientesContainer">
        <!-- Os cards de clientes ser√£o inseridos aqui dinamicamente -->
      </div>
    </div>
    <!-- Programa√ß√£o (agora em primeiro lugar) -->
    <div class="section-header" id="toggle-programacao">
      <span>üóì Programa√ß√£o</span>
      <i class="fas fa-chevron-down toggle-icon"></i>
    </div>
    <div class="section-content card" id="content-programacao">
      <div id="programacaoContent" class="table-wrap"></div>
    </div>
    <!-- Lotes de Entrega -->
    <div class="section-header" id="toggle-entrega">
      <span>üöö Lotes de Entrega</span>
      <i class="fas fa-chevron-down toggle-icon"></i>
    </div>
    <div class="section-content card" id="content-entrega">
      <div id="entregaContent" class="table-wrap"></div>
    </div>
    <!-- Lotes de Retirada -->
    <div class="section-header" id="toggle-retirada">
      <span>üì¶ Lotes de Retirada</span>
      <i class="fas fa-chevron-down toggle-icon"></i>
    </div>
    <div class="section-content card" id="content-retirada">
      <div id="retiradaContent" class="table-wrap"></div>
    </div>
  </div>
<script>
/* ====== CONFIG - coloque aqui seu SHEET_ID se mudar ====== */
const SHEET_ID = '1CZZgYJiZic9pyFFTdyldm_gVwn2K-zSGY9uhFJ5Nz6Q';
const GIDS = {
  entrega: '271702555',    // aba LOTES DE ENTREGA
  retirada: '585404986',   // aba LOTES RETIRADA
  programacao: '1183141602'// aba PROGRAMA√á√ÉO
};
// Configura√ß√£o do intervalo de atualiza√ß√£o autom√°tica (em milissegundos)
// 300000 = 5 minutos (5 * 60 * 1000)
const AUTO_UPDATE_INTERVAL = 300000;
/* colunas que ficam ocultas em exibi√ß√£o (aparecem em detalhes) - normalizadas */
const HIDDEN_COLS = ['nfp','royalties','safra'];
/* colunas removidas (normalizadas) de todas as tabelas */
const REMOVED_COMMON = ['localizacao','idorigemymvk1'];
/* colunas removidas especificamente da Programa√ß√£o (normalizadas) */
const REMOVED_PROGRAMACAO = [
  'observacoes','ordem','notafiscal','dacte','mdfe','conftipocam','agendamento',
  'descarga','comprovantededescarga','horarioprev','classificacaodestino','chaveid',
  'frete', 'statusagendamento', 'datadedescarga', 'notafiscal' // Adicionadas conforme solicita√ß√£o
];
/* Normaliza cabe√ßalho: remove acento, espa√ßos e pontua√ß√£o */
function normalizeHeader(h){
  if(h === undefined || h === null) return '';
  return String(h).trim().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'').replace(/[^a-z0-9]/g,'');
}
/* Normaliza texto: remove acentos ‚Äî reutiliz√°vel para status */
function normalizeText(text) {
  if(text === undefined || text === null) return '';
  return String(text).trim().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'');
}
/* Parse CSV tolerante (trata v√≠rgulas dentro de aspas)
   Retorna { arrays: [ [col1,col2,...], ... ], headersOrig: [], headersNorm: [], objects: [ {normKey: value}, ... ] }
*/
function parseCSV(text){
  if(!text) return {arrays:[], headersOrig:[], headersNorm:[], objects:[]};
  const lines = text.split(/\r?\n/).filter(l => l.trim() !== ''); // Corrigido: express√£o regular v√°lida
  if(lines.length === 0) return {arrays:[], headersOrig:[], headersNorm:[], objects:[]};
  const parsed = lines.map(line => line.split(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/).map(c => c.replace(/^"|"$/g,'').trim()));
  const headersOrig = parsed.shift().map(h => h||'');
  const headersNorm = headersOrig.map(h => normalizeHeader(h));
  const objects = parsed.map(cells => {
    const obj = {};
    headersNorm.forEach((key, idx) => {
      obj[key] = cells[idx] !== undefined ? cells[idx] : '';
    });
    return obj;
  });
  return {arrays: parsed, headersOrig, headersNorm, objects};
}
/* fetch CSV via gviz - retorna parseCSV result */
async function fetchSheetByGid(gid){
  const url = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:csv&gid=${gid}`;
  const r = await fetch(url);
  if(!r.ok) throw new Error('Erro ao buscar planilha: ' + r.status);
  const text = await r.text();
  return parseCSV(text);
}
/* util: parse number tolerant */
function parseNumber(val){
  if(val === undefined || val === null) return NaN;
  const s = String(val).replace(/\s/g,'').replace(/\./g,'').replace(/,/g,'.');
  const n = parseFloat(s.replace(/[^\d\.\-]/g,''));
  return isNaN(n) ? NaN : n;
}
/* util: parse date only (dd/mm/yyyy ou yyyy-mm-dd) -> Date (00:00:00) or null */
function parseDateOnly(s){
  if(!s) return null;
  const str = String(s).trim();
  // dd/mm/yyyy
  if(str.includes('/')){
    const parts = str.split('/');
    if(parts.length >= 3){
      const d = parseInt(parts[0],10), m = parseInt(parts[1],10), y = parseInt(parts[2],10);
      if(!isNaN(d) && !isNaN(m) && !isNaN(y)) return new Date(y, m-1, d);
    }
  }
  // yyyy-mm-dd or yyyy/mm/dd
  if(str.includes('-') || (str.includes('/') && str.indexOf('/') === 4)){
    const sep = str.includes('-')? '-' : '/';
    const parts = str.split(sep);
    if(parts.length >= 3){
      const y = parseInt(parts[0],10), m = parseInt(parts[1],10), d = parseInt(parts[2],10);
      if(!isNaN(d) && !isNaN(m) && !isNaN(y)) return new Date(y, m-1, d);
    }
  }
  const dt = new Date(str);
  if(!isNaN(dt.getTime())) return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());
  return null;
}
/* encontra header normalizado que contenha um dos padr√µes */
function findHeaderKey(headersNorm, patterns){
  for(const p of patterns){
    const f = headersNorm.find(h => h.includes(p));
    if(f) return f;
  }
  // fallbacks inteligentes
  if(patterns.includes('saldoent')){
    const f = headersNorm.find(h => h.includes('saldo') && (h.includes('ent') || h.includes('entrega') || h.includes('entkg')));
    if(f) return f;
  }
  if(patterns.includes('saldoret')){
    const f = headersNorm.find(h => h.includes('saldo') && (h.includes('ret') || h.includes('retirada') || h.includes('retkg')));
    if(f) return f;
  }
  if(patterns.some(x => x.includes('contrato'))){
    const f = headersNorm.find(h => h.includes('contrato'));
    if(f) return f;
  }
  // any saldo
  const f = headersNorm.find(h => h.includes('saldo'));
  if(f) return f;
  return null;
}
/* Formata n√∫mero como moeda brasileira */
function formatCurrencyBRL(value) {
  if (isNaN(value)) return value;
  return new Intl.NumberFormat('pt-BR', {
    style: 'currency',
    currency: 'BRL'
  }).format(value);
}
/* Formata o status da programa√ß√£o com cores espec√≠ficas ‚Äî CORRIGIDA */
function formatStatusProgramacao(status) {
  let className = 'status-programacao';
  let text = status;
  // Normalizar o status para compara√ß√£o (remover acentos)
  const statusNorm = normalizeText(status);
  if (statusNorm.includes('carregado')) {
    className += ' status-carregado';
  } else if (statusNorm.includes('embarque') || statusNorm.includes('no embarque')) {
    className += ' status-embarque';
  } else if (statusNorm.includes('transito') || statusNorm.includes('em transito')) {
    className += ' status-transito';
  } else if (statusNorm.includes('contratar')) {
    className += ' status-contratar';
  } else {
    // Status padr√£o (cinza)
    className += ' status-aberto';
  }
  return `<span class="${className}">${escapeHtml(text)}</span>`;
}
/* build table HTML: rowsArrays = array of arrays; rowsObjects = array of objects keyed by normalized headers */
function buildTableHTML(rowsArrays, rowsObjects, headersOrig, headersNorm, opts){
  // opts: {hiddenNorm:[], removedNorm:[], numericKey: 'somenorm', forceColsNorm:[], currencyCols:[], statusCol: ''}
  const hiddenNorm = opts.hiddenNorm || [];
  const removedNorm = opts.removedNorm || [];
  const numericKey = opts.numericKey || '';
  const forceInclude = opts.forceInclude || [];
  const currencyCols = opts.currencyCols || [];
  const statusCol = opts.statusCol || '';
  // visible columns: headersNorm minus removed
  const visible = headersNorm.filter(h => !removedNorm.includes(h));
  // display columns exclude hidden
  let displayCols = visible.filter(h => !hiddenNorm.includes(h));
  // ensure forced columns appear first
  forceInclude.forEach(fc => {
    if(visible.includes(fc) && !displayCols.includes(fc)) displayCols.unshift(fc);
    else if(visible.includes(fc)) displayCols = [fc, ...displayCols.filter(x => x !== fc)];
  });
  if(displayCols.length === 0){
    return '<div class="empty">Sem colunas para exibir.</div>';
  }
  // construct header titles using originals
  let html = '<table><thead><tr>';
  displayCols.forEach(h => {
    const idx = headersNorm.indexOf(h);
    const title = (idx>=0 ? headersOrig[idx] : h) || h;
    html += `<th>${escapeHtml(title)}</th>`;
  });
  if(numericKey) html += '<th>Status</th>';
  html += '</tr></thead><tbody>';
  rowsObjects.forEach((obj, i) => {
    const arr = rowsArrays[i] || [];
    const n = numericKey ? parseNumber( obj[numericKey] || arr[numericKeyIndex(headersNorm, numericKey)] || '0' ) : NaN;
    html += '<tr>';
    displayCols.forEach(h => {
      // prefer object value, fallback to array by index if available
      const idx = headersNorm.indexOf(h);
      let value = (obj[h] !== undefined && obj[h] !== '') ? obj[h] : (arr[idx] !== undefined ? arr[idx] : '');
      // Formatar como moeda se for uma coluna de moeda
      if(currencyCols.includes(h)) {
        const numValue = parseNumber(value);
        if(!isNaN(numValue)) {
          value = formatCurrencyBRL(numValue);
        }
      }
      // Formatar status da programa√ß√£o
      if(h === statusCol) {
        value = formatStatusProgramacao(value);
        html += `<td>${value}</td>`;
      } else {
        html += `<td>${escapeHtml(value)}</td>`;
      }
    });
    if(numericKey) html += `<td>${n>0?'<span class="status status-aberto">ABERTO</span>':'<span class="status status-fechado">FECHADO</span>'}</td>`;
    html += '</tr>';
  });
  html += '</tbody></table>';
  return html;
}
// helper: get index of normalized key (or -1)
function numericKeyIndex(headersNorm, key){ return headersNorm.indexOf(key); }
function escapeHtml(s){
  if(s === undefined || s === null) return '';
  return String(s).replace(/[&<>"'\/]/g, c => ({'&':'&amp;','<':'<','>':'>','"':'&quot;',"'":'&#x27;','/':'&#x2F;'}[c]));
}
/* Contar status da programa√ß√£o ‚Äî CORRIGIDA */
function countStatusProgramacao(rowsObjects, statusCol) {
  let carregado = 0, embarque = 0, transito = 0, contratar = 0;
  if(!statusCol) return {carregado, embarque, transito, contratar};
  rowsObjects.forEach(obj => {
    const status = obj[statusCol] || '';
    const statusNorm = normalizeText(status); // Normaliza removendo acentos
    if (statusNorm.includes('carregado')) {
      carregado++;
    } else if (statusNorm.includes('embarque') || statusNorm.includes('no embarque')) {
      embarque++;
    } else if (statusNorm.includes('transito') || statusNorm.includes('em transito')) {
      transito++;
    } else if (statusNorm.includes('contratar')) {
      contratar++;
    }
  });
  return {carregado, embarque, transito, contratar};
}
/* Extrair produto do texto (√∫ltima parte ap√≥s o √∫ltimo tra√ßo) */
function extractProduto(text) {
  if(!text) return '';
  // Dividir por tra√ßos e pegar a √∫ltima parte
  const parts = text.split('-');
  if(parts.length === 0) return '';
  // Pegar a √∫ltima parte e remover espa√ßos
  let produto = parts[parts.length - 1].trim().toLowerCase();
  // Remover poss√≠veis n√∫meros ou caracteres especiais no final
  produto = produto.replace(/[0-9\.\,\(\)\[\]]/g, '').trim();
  return produto;
}
/* NOVA FUN√á√ÉO: Extrair informa√ß√µes do contrato da coluna C (INFORMA√á√ïES DO DESTINO) */
function extractContratoInfo(text) {
  if(!text || text.trim() === '') return {contrato: '', cliente: '', destino: '', produto: '', isValid: false};
  const parts = text.split(' - ').map(part => part.trim());
  // Verificar se temos pelo menos 6 partes: contrato, cliente, cliente (repetido), destino, estado, produto
  if(parts.length < 6) {
    // fallback: tentar extrair contrato do primeiro trecho antes do primeiro tra√ßo
    const first = text.split('-')[0] ? text.split('-')[0].trim() : '';
    const contratoFallback = first.replace(/\D/g,'');
    // tentar extrair cliente/destino de forma simples
    const cliente = parts[1] || '';
    const destino = parts[3] || '';
    const produto = parts.slice(5).join(' - ').trim().toUpperCase() || (parts[parts.length-1]||'').toUpperCase();
    const isValidFallback = contratoFallback !== '' && cliente !== '' && destino !== '';
    return {
      contrato: contratoFallback,
      cliente: cliente,
      destino: destino,
      produto: produto,
      isValid: isValidFallback
    };
  }
  // Seguir exatamente o padr√£o fornecido:
  // 0: contrato, 1: cliente, 2: cliente (repetido - ignorar), 3: destino, 4: estado (ignorar), 5+: produto
  const contrato = parts[0].replace(/\D/g, ''); // Apenas n√∫meros
  const cliente = parts[1]; // Segunda parte (ap√≥s o primeiro tra√ßo)
  const destino = parts[3]; // Quarta parte (ap√≥s o terceiro tra√ßo)
  const produtoParts = parts.slice(5);
  let produto = produtoParts.join(' - ').trim().toUpperCase();
  if(!produto) {
    produto = parts[parts.length - 1].trim().toUpperCase();
  }
  const isValid = contrato !== '' && cliente !== '' && destino !== '' && produto !== '';
  return {
    contrato: contrato,
    cliente: cliente,
    destino: destino,
    produto: produto,
    isValid: isValid
  };
}
/* Calcular totais por produto - ADICIONADA DE VOLTA */
function calculateProdutosTotais(rowsObjects, produtoColIndex, pesoColIndex, destinoColIndex) {
  let soja = 0, milho = 0, sorgo = 0;
  rowsObjects.forEach(obj => {
    // Verificar se tem informa√ß√µes na coluna C (destino)
    let destinoText = '';
    if(destinoColIndex !== -1) {
      if(Array.isArray(obj) && obj[destinoColIndex] !== undefined) {
        destinoText = obj[destinoColIndex];
      }
    }
    // Extrair informa√ß√µes do destino usando a nova fun√ß√£o
    const {isValid} = extractContratoInfo(destinoText);
    // S√≥ considerar se tiver informa√ß√µes v√°lidas de destino
    if(!isValid) return;
    // Pegar o valor da coluna de produto (coluna B - √≠ndice 1)
    let produtoText = '';
    if(produtoColIndex !== -1) {
      if(Array.isArray(obj) && obj[produtoColIndex] !== undefined) {
        produtoText = obj[produtoColIndex];
      }
    }
    // Extrair o produto
    const produto = extractProduto(produtoText);
    // Pegar o peso (coluna J - √≠ndice 9)
    let pesoText = '';
    if(pesoColIndex !== -1) {
      if(Array.isArray(obj) && obj[pesoColIndex] !== undefined) {
        pesoText = obj[pesoColIndex];
      }
    }
    const peso = parseNumber(pesoText);
    if(isNaN(peso)) return;
    // Somar ao produto correspondente
    if(produto.includes('soja')) {
      soja += peso;
    } else if(produto.includes('milho')) {
      milho += peso;
    } else if(produto.includes('sorgo')) {
      sorgo += peso;
    }
  });
  return {soja, milho, sorgo};
}
/* Atualizar o texto da √∫ltima atualiza√ß√£o */
function updateLastUpdateTime() {
  const now = new Date();
  const timeString = now.toLocaleTimeString('pt-BR');
  const dateString = now.toLocaleDateString('pt-BR');
  document.getElementById('lastUpdate').innerHTML = `
    <i class="fas fa-check-circle" style="color: #10b981;"></i>
    <span>√öltima atualiza√ß√£o: ${timeString} - ${dateString}</span>
  `;
}
/* Formata n√∫mero com separadores de milhar */
function formatNumber(value) {
  if(isNaN(value)) return '0';
  return new Intl.NumberFormat('pt-BR').format(Math.round(value));
}

/* NOVA FUN√á√ÉO: Extrair peso da coluna I (ex: "LS - 6 EIXOS - 32 TON") */
function extractWeightFromColumnI(text) {
  if(!text || text.trim() === '') return 0;
  // Dividir por tra√ßos e pegar a √∫ltima parte
  const parts = text.split('-');
  if(parts.length === 0) return 0;
  
  // Pegar a √∫ltima parte
  let lastPart = parts[parts.length - 1].trim();
  
  // Extrair o n√∫mero da √∫ltima parte (antes de "TON" ou qualquer outra unidade)
  const match = lastPart.match(/(\d+)/);
  if(match && match[1]) {
    const tons = parseInt(match[1], 10);
    // Converter para KG (1 ton = 1000 kg)
    return tons * 1000;
  }
  
  return 0;
}

/* Gerar HTML para os cards de clientes (agora por contrato) */
function buildClientesHTML(clientes) {
  if(clientes.length === 0) {
    return '<div class="empty">Nenhum contrato encontrado para hoje.</div>';
  }
  let html = '';
  clientes.forEach(cliente => {
    // Definir cor do produto
    let corProduto = '#6b7280'; // Cinza padr√£o
    const produtoUp = (cliente.produto || '').toUpperCase();
    if(produtoUp.includes('SOJA')) {
      corProduto = '#10b981'; // Verde para Soja
    } else if(produtoUp.includes('MILHO')) {
      corProduto = '#fbbf24'; // Amarelo para Milho
    } else if(produtoUp.includes('SORGO')) {
      corProduto = '#6b7280'; // Cinza para Sorgo
    }
    
    // Calcular o saldo ajustado (subtrair peso de ve√≠culos em tr√¢nsito/embarque)
    let saldoEntregaAjustado = cliente.saldoEntrega || 0;
    if(cliente.pesoEmTransitoEmbarque && !isNaN(cliente.pesoEmTransitoEmbarque)) {
      saldoEntregaAjustado -= cliente.pesoEmTransitoEmbarque;
      if(saldoEntregaAjustado < 0) saldoEntregaAjustado = 0; // N√£o permitir saldo negativo
    }
    
    // Formatar saldo de entrega ajustado
    const saldoEntregaDisplay = !isNaN(saldoEntregaAjustado) ? `${formatNumber(saldoEntregaAjustado)} KG` : '0 KG';
    
    html += `
      <div class="cliente-card">
        <h3 class="cliente-name">Contrato: ${escapeHtml(cliente.contrato)}</h3>
        <div class="cliente-destino">${escapeHtml(cliente.cliente)} - ${escapeHtml(cliente.destino)}</div>
        <div class="cliente-info">
          <span class="info-label">Produto:</span>
          <span class="cliente-produto" style="background-color: ${corProduto}; color: white;">${escapeHtml(cliente.produto)}</span>
        </div>
        <div class="caminhoes-info">
          <div class="caminhoes-separados">
            <span class="status-carregado-tag">Carregados: ${cliente.totalCaminhoesCarregados}</span>
            <span class="status-pendente-tag">Pendentes: ${cliente.totalCaminhoesPendentes}</span>
          </div>
        </div>
        <div class="cliente-info" style="margin-top: 8px;">
          <span class="info-label">Peso Carregado:</span>
          <span class="info-value">${formatNumber(cliente.totalPesoCarregado)} KG</span>
        </div>
        <div class="cliente-info" style="margin-top: 6px;">
          <span class="info-label">Saldo Entrega:</span>
          <span class="info-value">${escapeHtml(saldoEntregaDisplay)}</span>
        </div>
        ${cliente.pesoEmTransitoEmbarque && cliente.pesoEmTransitoEmbarque > 0 ? 
          `<div class="cliente-info" style="margin-top: 6px; font-size: 12px; color: #ef4444;">
            <span class="info-label">Peso em Tr√¢nsito/Embarque:</span>
            <span class="info-value">${formatNumber(cliente.pesoEmTransitoEmbarque)} KG</span>
          </div>` : ''}
      </div>
    `;
  });
  return html;
}

/* Atualizar o resumo de clientes */
function updateClientesSummary(clientes) {
  const totalContratos = clientes.length;
  const totalCaminhoes = clientes.reduce((sum, cliente) => sum + (cliente.totalCaminhoes||0), 0);
  const totalPeso = clientes.reduce((sum, cliente) => sum + (cliente.totalPeso||0), 0);
  const totalCaminhoesCarregados = clientes.reduce((sum, cliente) => sum + (cliente.totalCaminhoesCarregados||0), 0);
  const totalCaminhoesPendentes = clientes.reduce((sum, cliente) => sum + (cliente.totalCaminhoesPendentes||0), 0);
  // Somar saldo de entrega total ajustado
  const totalSaldoEntregaAjustado = clientes.reduce((sum, cliente) => {
    let saldoAjustado = (cliente.saldoEntrega || 0);
    if(cliente.pesoEmTransitoEmbarque && !isNaN(cliente.pesoEmTransitoEmbarque)) {
      saldoAjustado -= cliente.pesoEmTransitoEmbarque;
      if(saldoAjustado < 0) saldoAjustado = 0;
    }
    return sum + saldoAjustado;
  }, 0);
  document.getElementById('clientesSummary').innerHTML = `
    ${totalContratos} contratos ‚Ä¢ ${totalCaminhoesCarregados} carregados ‚Ä¢ ${totalCaminhoesPendentes} pendentes ‚Ä¢ ${formatNumber(totalPeso)} KG ‚Ä¢ Saldo: ${formatNumber(totalSaldoEntregaAjustado)} KG
  `;
}

/* --- FUN√á√ÉO QUE AGRUPA POR CONTRATO --- */
async function groupByContract(rowsProg, destinoColIndex, placaColIndex, statusColIndex, includeFutureDates = false) {
  const grupos = {};
  // Se includeFutureDates for false, filtramos apenas por data de hoje
  let rowsToProcess = rowsProg;
  if (!includeFutureDates) {
    const today = new Date();
    const todayStart = new Date(today.getFullYear(), today.getMonth(), today.getDate()).getTime();
    const dateIndexProg = 0; // assumindo que a data est√° na primeira coluna
    rowsToProcess = rowsProg.filter(arr => {
      let dtVal = '';
      if(arr && arr[dateIndexProg] !== undefined) dtVal = arr[dateIndexProg];
      const dt = parseDateOnly(dtVal);
      return dt && dt.getTime() === todayStart;
    });
  }
  // Processar cada linha
  rowsToProcess.forEach(arr => {
    // Extrair informa√ß√µes da coluna C (√≠ndice fornecido)
    let destinoText = '';
    if(destinoColIndex !== -1) {
      if(Array.isArray(arr) && arr[destinoColIndex] !== undefined) {
        destinoText = arr[destinoColIndex];
      }
    }
    // Usar a fun√ß√£o para extrair contrato, cliente, destino e produto
    const {contrato, cliente, destino, produto, isValid} = extractContratoInfo(destinoText);
    // S√≥ processar se tivermos um contrato v√°lido
    if(!isValid || !contrato) return;
    const key = `contrato_${contrato}`;
    // Pegar peso real da coluna J (√≠ndice 9)
    let pesoRealText = '';
    if(Array.isArray(arr) && arr[9] !== undefined) {
      pesoRealText = arr[9];
    }
    const pesoReal = parseNumber(pesoRealText) || 0;
    // Pegar placa da coluna H (√≠ndice 7)
    let placa = '';
    if(placaColIndex !== -1) {
      if(Array.isArray(arr) && arr[placaColIndex] !== undefined) {
        placa = arr[placaColIndex];
      }
    }
    // Pegar status da coluna STATUS (statusColIndex)
    let status = '';
    if(statusColIndex !== -1) {
      if(Array.isArray(arr) && arr[statusColIndex] !== undefined) {
        status = arr[statusColIndex];
      }
    }
    const statusNorm = normalizeText(status);
    const isCarregado = statusNorm.includes('carregado');
    const isEmbarque = statusNorm.includes('embarque') || statusNorm.includes('no embarque');
    const isTransito = statusNorm.includes('transito') || statusNorm.includes('em transito');
    
    // Inicializar grupo se n√£o existir
    if(!grupos[key]) {
      grupos[key] = {
        contrato: contrato,
        cliente: cliente,
        destino: destino,
        produto: produto,
        totalPeso: 0,
        totalPesoCarregado: 0,
        totalPesoPendente: 0,
        placas: new Set(),
        placasCarregadas: new Set(),
        placasPendentes: new Set(),
        count: 0,
        pesoEmTransitoEmbarque: 0 // Novo campo para armazenar peso em tr√¢nsito/embarque
      };
    }
    // Atualizar valores gerais
    grupos[key].totalPeso += pesoReal;
    if(placa && placa.trim() !== '') {
      grupos[key].placas.add(placa.trim());
    }
    // Separar por status
    if(isCarregado) {
      grupos[key].totalPesoCarregado += pesoReal;
      if(placa && placa.trim() !== '') {
        grupos[key].placasCarregadas.add(placa.trim());
      }
    } else {
      grupos[key].totalPesoPendente += pesoReal;
      if(placa && placa.trim() !== '') {
        grupos[key].placasPendentes.add(placa.trim());
      }
    }
    grupos[key].count++;
    
    // Se estiver em tr√¢nsito ou no embarque, extrair peso da coluna I e somar
    if(isEmbarque || isTransito) {
      let textoColunaI = '';
      if(Array.isArray(arr) && arr[8] !== undefined) { // Coluna I = √≠ndice 8
        textoColunaI = arr[8];
      }
      const pesoExtraido = extractWeightFromColumnI(textoColunaI);
      grupos[key].pesoEmTransitoEmbarque += pesoExtraido;
    }
  });
  // Converter para array e formatar
  return Object.values(grupos).map(grupo => ({
    ...grupo,
    totalPeso: Math.round(grupo.totalPeso),
    totalPesoCarregado: Math.round(grupo.totalPesoCarregado),
    totalPesoPendente: Math.round(grupo.totalPesoPendente),
    totalCaminhoes: grupo.placas.size,
    totalCaminhoesCarregados: grupo.placasCarregadas.size,
    totalCaminhoesPendentes: grupo.placasPendentes.size,
    placas: Array.from(grupo.placas),
    placasCarregadas: Array.from(grupo.placasCarregadas),
    placasPendentes: Array.from(grupo.placasPendentes),
    pesoEmTransitoEmbarque: Math.round(grupo.pesoEmTransitoEmbarque) // Arredondar para exibi√ß√£o
  })).sort((a, b) => b.totalPeso - a.totalPeso); // Ordenar por peso total decrescente
}

/* --- Main load function --- */
async function loadAll(isAutoUpdate = false){
  try{
    if(isAutoUpdate) {
      document.body.classList.add('updating');
    }
    // ===== PROGRAMA√á√ÉO (agora em primeiro lugar) =====
    const prog = await fetchSheetByGid(GIDS.programacao);
    const rowsArrProg = prog.arrays;
    const headersOrigProg = prog.headersOrig;
    const headersNormProg = prog.headersNorm;
    const objsProg = prog.objects;
    // Encontrar a coluna "STATUS"
    const statusKey = headersNormProg.find(h => h.includes('status') && !h.includes('agendamento')) || null;
    const statusIndex = headersNormProg.indexOf(statusKey);
    // find date key (fallback index 0)
    const dateKeyProg = findHeaderKey(headersNormProg, ['data','dataprogramacao','dataprog','dataentrega']) || headersNormProg[0] || null;
    const dateIndexProg = 0;
    const today = new Date(); const todayStart = new Date(today.getFullYear(), today.getMonth(), today.getDate()).getTime();
    const rowsArrProgFiltered = [];
    const rowsObjProgFiltered = [];
    for(let i=0;i<rowsArrProg.length;i++){
      const arr = rowsArrProg[i];
      const obj = objsProg[i] || {};
      // get date
      let dtVal = '';
      if(dateKeyProg && obj[dateKeyProg]) dtVal = obj[dateKeyProg];
      else if(arr[dateIndexProg] !== undefined) dtVal = arr[dateIndexProg];
      const dt = parseDateOnly(dtVal);
      if(dt && dt.getTime() === todayStart){
        rowsArrProgFiltered.push(arr);
        rowsObjProgFiltered.push(obj);
      }
    }
    // ===== LOTES DE ENTREGA: buscar e construir mapa de saldo por contrato =====
    const ent = await fetchSheetByGid(GIDS.entrega);
    const rowsArrEnt = ent.arrays;
    const headersOrigEnt = ent.headersOrig;
    const headersNormEnt = ent.headersNorm;
    const objsEnt = ent.objects;
    // detect keys √∫teis
    const infoDestinoKey = headersNormEnt.find(h => h.includes('informacoesdestino') || h.includes('informacaodestino') || h.includes('destino'));
    const saldoKeyEnt = findHeaderKey(headersNormEnt, ['saldoent','saldoentrega','saldoentkg']) || null;
    const saldoIndexEnt = 8; // coluna I -> √≠ndice 8 (fallback)
    const existingContratoKeys = headersNormEnt.filter(h => h.includes('contrato') || h.includes('ncontrato') || h.includes('numerocontrato'));
    // Mapa de saldo por contrato (normalizando o contrato para somente d√≠gitos)
    const saldoPorContrato = {};
    for(let i=0;i<rowsArrEnt.length;i++){
      const arr = rowsArrEnt[i] || [];
      const obj = objsEnt[i] || {};
      // extrair contrato preferencialmente da coluna B (arr[1]) ou da infoDestinoKey
      let contratoRaw = '';
      if(infoDestinoKey && obj[infoDestinoKey]) {
        // tentar obter a parte antes do primeiro tra√ßo
        contratoRaw = String(obj[infoDestinoKey]).split('-')[0].trim();
      } else if(arr[1] !== undefined && String(arr[1]).trim() !== '') {
        contratoRaw = String(arr[1]).trim();
      } else {
        // fallback: qualquer coluna de contrato existente no header
        for(const k of existingContratoKeys) {
          if(obj[k]) { contratoRaw = String(obj[k]).trim(); break; }
        }
      }
      // normalizar para somente d√≠gitos (mesma l√≥gica do extractContratoInfo)
      let contratoNorm = String(contratoRaw || '').replace(/\D/g,'').trim();
      if(!contratoNorm) {
        // se n√£o houver d√≠gitos, usar o raw como fallback (sem espa√ßos)
        contratoNorm = String(contratoRaw || '').trim();
      }
      // pegar saldo preferencialmente pelo header encontrado, sen√£o pela posi√ß√£o
      let saldoVal = '';
      if(saldoKeyEnt && obj[saldoKeyEnt] !== undefined && obj[saldoKeyEnt] !== '') saldoVal = obj[saldoKeyEnt];
      else if(arr[saldoIndexEnt] !== undefined) saldoVal = arr[saldoIndexEnt];
      const n = parseNumber(saldoVal || '0');
      if(!isNaN(n) && contratoNorm) {
        saldoPorContrato[contratoNorm] = (saldoPorContrato[contratoNorm]||0) + n;
      }
    }
    // ===== filtrar ENTregas abertas (para a tabela) =====
    let removedEnt = [...REMOVED_COMMON.map(normalizeHeader)];
    const idDestinoKey = headersNormEnt.find(h => h.includes('iddestino') || h.includes('id_destino'));
    const situacaoEntKey = headersNormEnt.find(h => h.includes('situacaoent') || h.includes('situacao') || h.includes('situacaoentrega'));
    if(infoDestinoKey) removedEnt.push(infoDestinoKey);
    if(idDestinoKey) removedEnt.push(idDestinoKey);
    if(situacaoEntKey) removedEnt.push(situacaoEntKey);
    existingContratoKeys.forEach(key => {
      if(!removedEnt.includes(key)) removedEnt.push(key);
    });
    const rowsObjEntFiltered = [];
    const rowsArrEntFiltered = [];
    for(let i=0;i<rowsArrEnt.length;i++){
      const arr = rowsArrEnt[i];
      let obj = {...objsEnt[i]} || {};
      // Extrair n√∫mero do contrato de "INFORMA√á√ïES DESTINO" ou coluna B
      let contratoNumero = '';
      if(infoDestinoKey && obj[infoDestinoKey]) {
        const valorDestino = obj[infoDestinoKey];
        if(String(valorDestino).includes('-')) {
          contratoNumero = String(valorDestino).split('-')[0].trim();
        } else {
          contratoNumero = String(valorDestino).trim();
        }
      } else {
        if(arr && arr[1] !== undefined) {
          contratoNumero = arr[1];
        }
      }
      obj['numero_contrato'] = contratoNumero;
      let saldoVal = '';
      if(saldoKeyEnt && obj[saldoKeyEnt] !== undefined && obj[saldoKeyEnt] !== '') saldoVal = obj[saldoKeyEnt];
      else if(arr && arr[saldoIndexEnt] !== undefined) saldoVal = arr[saldoIndexEnt];
      const n = parseNumber(saldoVal || '0');
      if(!isNaN(n) && n > 0){
        rowsObjEntFiltered.push(obj);
        rowsArrEntFiltered.push(arr);
      }
    }
    // Adicionar a nova coluna de contrato aos cabe√ßalhos (se ainda n√£o tiver)
    if(!headersNormEnt.includes('numero_contrato')) {
      headersNormEnt.push('numero_contrato');
      headersOrigEnt.push('N¬∫ CONTRATO');
    }
    // build table entrega
    const hiddenEnt = HIDDEN_COLS.map(normalizeHeader);
    const forceIncludeEnt = ['numero_contrato'];
    const tableEntHTML = buildTableHTML(rowsArrEntFiltered, rowsObjEntFiltered, headersOrigEnt, headersNormEnt, {
      hiddenNorm: hiddenEnt,
      removedNorm: removedEnt,
      numericKey: saldoKeyEnt || headersNormEnt[saldoIndexEnt] || '',
      forceInclude: forceIncludeEnt
    });
    // ===== LOTES DE RETIRADA =====
    const ret = await fetchSheetByGid(GIDS.retirada);
    const rowsArrRet = ret.arrays;
    const headersOrigRet = ret.headersOrig;
    const headersNormRet = ret.headersNorm;
    const objsRet = ret.objects;
    // Remove INFORMA√á√ïES ORIGEM from display
    const removedRet = [...REMOVED_COMMON.map(normalizeHeader)];
    const possOrigem = headersNormRet.find(h => h.includes('origem') && (h.includes('informacao') || h.includes('informacoes')));
    if(possOrigem) removedRet.push(possOrigem);
    const hiddenRet = HIDDEN_COLS.map(normalizeHeader);
    const saldoKeyRet = findHeaderKey(headersNormRet, ['saldoret','saldoretkg','saldoretirada']) || null;
    const saldoIndexRet = 9;
    const rowsObjRetFiltered = [];
    const rowsArrRetFiltered = [];
    for(let i=0;i<rowsArrRet.length;i++){
      const arr = rowsArrRet[i];
      const obj = objsRet[i] || {};
      let saldoVal = '';
      if(saldoKeyRet && obj[saldoKeyRet] !== undefined && obj[saldoKeyRet] !== '') saldoVal = obj[saldoKeyRet];
      else if(arr && arr[saldoIndexRet] !== undefined) saldoVal = arr[saldoIndexRet];
      const n = parseNumber(saldoVal || '0');
      if(!isNaN(n) && n > 0){
        rowsObjRetFiltered.push(obj);
        rowsArrRetFiltered.push(arr);
      }
    }
    const tableRetHTML = buildTableHTML(rowsArrRetFiltered, rowsObjRetFiltered, headersOrigRet, headersNormRet, {
      hiddenNorm: hiddenRet,
      removedNorm: removedRet,
      numericKey: saldoKeyRet || headersNormRet[saldoIndexRet] || ''
    });
    // ===== CONTADORES E TABELA DE PROGRAMA√á√ÉO =====
    // Contar status para os cards (aqui usamos os objetos filtrados)
    const statusCounts = countStatusProgramacao(rowsObjProgFiltered, statusKey);
    document.getElementById('count-carregado').textContent = statusCounts.carregado;
    document.getElementById('count-embarque').textContent = statusCounts.embarque;
    document.getElementById('count-transito').textContent = statusCounts.transito;
    document.getElementById('count-contratar').textContent = statusCounts.contratar;
    // Calcular totais por produto (coluna B = √≠ndice 1, coluna J = √≠ndice 9, coluna C = √≠ndice 2)
    const produtosTotais = calculateProdutosTotais(rowsArrProgFiltered, 1, 9, 2);
    document.getElementById('count-soja').textContent = formatNumber(produtosTotais.soja);
    document.getElementById('count-milho').textContent = formatNumber(produtosTotais.milho);
    document.getElementById('count-sorgo').textContent = formatNumber(produtosTotais.sorgo);
    // Agrupar por contrato (usa rowsArrProgFiltered) - agora passando o √≠ndice da coluna I (8)
    // Primeiro: calcular peso em tr√¢nsito/embarque considerando TODAS as datas
    const clientesComPesoFuturo = await groupByContract(rowsArrProg, 2, 7, statusIndex, true);
    // Segundo: agrupar apenas para hoje (para exibi√ß√£o)
    const clientesParaHoje = await groupByContract(rowsArrProgFiltered, 2, 7, statusIndex, false);
    // --- AQUI: AMARRAR O SALDO DA ABA ENTREGA AO CONTRATO DOS CARDS ---
    // Note: groupByContract cria cliente.contrato j√° apenas com d√≠gitos (mesma normaliza√ß√£o)
    clientesParaHoje.forEach(c => {
      // normalizar chave tal qual fizemos ao criar saldoPorContrato
      const key = String(c.contrato || '').replace(/\D/g,'').trim() || String(c.contrato||'').trim();
      c.saldoEntrega = saldoPorContrato[key] || 0;
      // Buscar o peso em tr√¢nsito/embarque calculado com todas as datas
      const clienteFuturo = clientesComPesoFuturo.find(cf => cf.contrato === c.contrato);
      if(clienteFuturo) {
        c.pesoEmTransitoEmbarque = clienteFuturo.pesoEmTransitoEmbarque || 0;
      }
    });
    // Atualizar DOM: cards e resumo
    document.getElementById('clientesContainer').innerHTML = buildClientesHTML(clientesParaHoje);
    updateClientesSummary(clientesParaHoje);
    // Build programacao table: remove removedProg columns, format status and currency
    let removedProg = [...REMOVED_COMMON.map(normalizeHeader), ...REMOVED_PROGRAMACAO.map(normalizeHeader)];
    // Se tivermos colunas suficientes, remover a pen√∫ltima
    if(headersNormProg.length > 1) {
      const visibleCols = headersNormProg.filter(h => !removedProg.includes(h));
      if(visibleCols.length > 1) {
        const penultimaCol = visibleCols[visibleCols.length - 2];
        removedProg.push(penultimaCol);
      }
    }
    const freteEmpresaKey = headersNormProg.find(h => h.includes('freteempresa') || h.includes('frete') && h.includes('empresa')) || null;
    const tableProgHTML = buildTableHTML(rowsArrProgFiltered, rowsObjProgFiltered, headersOrigProg, headersNormProg, {
      hiddenNorm: HIDDEN_COLS.map(normalizeHeader),
      removedNorm: removedProg,
      numericKey: '',
      currencyCols: freteEmpresaKey ? [freteEmpresaKey] : [],
      statusCol: statusKey
    });
    // Inserir tabelas nas se√ß√µes
    document.getElementById('programacaoContent').innerHTML = tableProgHTML || '<div class="empty">Nenhuma programa√ß√£o para hoje.</div>';
    document.getElementById('entregaContent').innerHTML = tableEntHTML || '<div class="empty">Nenhum lote de entrega em aberto.</div>';
    document.getElementById('retiradaContent').innerHTML = tableRetHTML || '<div class="empty">Nenhum lote de retirada em aberto.</div>';
    // Inicialmente colapsar todas as se√ß√µes
    document.getElementById('content-entrega').classList.add('collapsed');
    document.getElementById('content-retirada').classList.add('collapsed');
    document.getElementById('content-programacao').classList.add('collapsed');
    document.getElementById('toggle-entrega').classList.add('collapsed');
    document.getElementById('toggle-retirada').classList.add('collapsed');
    document.getElementById('toggle-programacao').classList.add('collapsed');
    // Atualizar o texto da √∫ltima atualiza√ß√£o
    updateLastUpdateTime();
    document.body.classList.remove('updating');
  }
  catch(err){
    console.error('Erro loadAll:', err);
    document.getElementById('entregaContent').innerHTML = '<div class="empty">Erro ao carregar dados (ver console).</div>';
    document.getElementById('retiradaContent').innerHTML = '<div class="empty">Erro ao carregar dados (ver console).</div>';
    document.getElementById('programacaoContent').innerHTML = '<div class="empty">Erro ao carregar dados (ver console).</div>';
    document.getElementById('clientesContainer').innerHTML = '<div class="empty">Erro ao carregar dados dos contratos (ver console).</div>';
    document.getElementById('lastUpdate').innerHTML = `
      <i class="fas fa-exclamation-triangle" style="color: #ef4444;"></i>
      <span>Erro na atualiza√ß√£o - ${new Date().toLocaleTimeString('pt-BR')}</span>
    `;
    document.body.classList.remove('updating');
  }
}
/* Toggle sections */
function setupToggleHandlers() {
  document.getElementById('toggle-entrega').addEventListener('click', function() {
    toggleSection('entrega');
  });
  document.getElementById('toggle-retirada').addEventListener('click', function() {
    toggleSection('retirada');
  });
  document.getElementById('toggle-programacao').addEventListener('click', function() {
    toggleSection('programacao');
  });
}
function toggleSection(sectionId) {
  const content = document.getElementById(`content-${sectionId}`);
  const header = document.getElementById(`toggle-${sectionId}`);
  const isCollapsed = content.classList.contains('collapsed');
  if(isCollapsed) {
    content.classList.remove('collapsed');
    header.classList.remove('collapsed');
  } else {
    content.classList.add('collapsed');
    header.classList.add('collapsed');
  }
}
/* Configurar atualiza√ß√£o autom√°tica */
let autoUpdateInterval;
function startAutoUpdate() {
  // Executar imediatamente ao carregar
  loadAll(true);
  // Configurar intervalo para atualiza√ß√µes subsequentes (5 minutos)
  autoUpdateInterval = setInterval(() => {
    loadAll(true);
  }, AUTO_UPDATE_INTERVAL);
}
function stopAutoUpdate() {
  if(autoUpdateInterval) {
    clearInterval(autoUpdateInterval);
    autoUpdateInterval = null;
  }
}
/* init */
document.getElementById('btnRefresh').addEventListener('click', () => {
  loadAll(false); // Atualiza√ß√£o manual
});
// Setup toggle handlers and start auto update after DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
  setupToggleHandlers();
  startAutoUpdate();
  // Adicionar evento de visibilidade para pausar/recuperar atualiza√ß√µes
  document.addEventListener('visibilitychange', function() {
    if(document.hidden) {
      console.log('P√°gina oculta - pausando atualiza√ß√µes autom√°ticas');
    } else {
      console.log('P√°gina vis√≠vel - retomando atualiza√ß√µes autom√°ticas');
      // Atualizar imediatamente quando a p√°gina volta a ficar vis√≠vel
      loadAll(true);
    }
  });
});
</script>
</body>
</html>
